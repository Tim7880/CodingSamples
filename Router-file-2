# Path: api/app/routers/forum.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import desc, func, case
import sqlalchemy as sa
from typing import List, Optional

from app.db.database import get_db
from app.models.forum import ForumCategory, ForumThread, ForumPost, PostVote, ForumSubscription
from app.models.user import User
from app.schemas.forum import (
    ForumCategoryResponse, ForumThreadResponse, ForumPostResponse,
    ForumThreadBase, ForumPostBase, ForumThreadSummary, VoteResponse
)
from app.routers.auth import get_current_active_user
# NEW: Import CRUD functions
from app.crud import crud_forum

router = APIRouter()

@router.get("/forum/categories", response_model=List[ForumCategoryResponse])
async def get_all_categories(db: AsyncSession = Depends(get_db)):
    """Get all forum categories."""
    result = await db.execute(select(ForumCategory).order_by(ForumCategory.name))
    categories = result.scalars().all()
    return categories

@router.get("/forum/threads", response_model=List[ForumThreadSummary])
async def get_threads_by_category(category_id: int, db: AsyncSession = Depends(get_db)):
    """Get all threads for a specific category."""
    post_count_subquery = (
        select(ForumPost.thread_id, func.count(ForumPost.id).label("posts_count"))
        .group_by(ForumPost.thread_id)
        .subquery()
    )
    last_post_date_subquery = (
        select(ForumPost.thread_id, func.max(ForumPost.created_at).label("last_post_date"))
        .group_by(ForumPost.thread_id)
        .subquery()
    )
    
    query = (
        select(
            ForumThread,
            post_count_subquery.c.posts_count,
            last_post_date_subquery.c.last_post_date,
            User
        )
        .join(User, ForumThread.author_id == User.id)
        .outerjoin(post_count_subquery, ForumThread.id == post_count_subquery.c.thread_id)
        .outerjoin(last_post_date_subquery, ForumThread.id == last_post_date_subquery.c.thread_id)
        .filter(ForumThread.category_id == category_id)
        .order_by(ForumThread.is_pinned.desc(), desc(last_post_date_subquery.c.last_post_date))
    )
    
    threads_with_counts = await db.execute(query)
    
    results = []
    for thread, posts_count, last_post_date, author in threads_with_counts.all():
        thread_summary_data = {
            "id": thread.id,
            "title": thread.title,
            "category_id": thread.category_id,
            "author_id": thread.author_id,
            "is_locked": thread.is_locked,
            "is_pinned": thread.is_pinned,
            "created_at": thread.created_at,
            "posts_count": posts_count if posts_count is not None else 0,
            "last_post_date": last_post_date,
            "author": author
        }
        results.append(ForumThreadSummary(**thread_summary_data))
        
    return results

@router.get("/forum/threads/{thread_id}", response_model=ForumThreadResponse)
# MODIFIED: Add current_user as an optional dependency
async def get_single_thread(
    thread_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: Optional[User] = Depends(get_current_active_user)
):
    """Get a single thread and all its posts, including user's vote status."""
    user_id = current_user.id if current_user else None

    # Subquery to check if the current user has voted for a post
    has_voted_subquery = (
        select(PostVote.post_id)
        .filter(PostVote.user_id == user_id)
        .subquery()
    )

    result = await db.execute(
        select(ForumThread)
        .options(
            sa.orm.selectinload(ForumThread.posts).selectinload(ForumPost.author),
            sa.orm.selectinload(ForumThread.author)
        )
        .filter(ForumThread.id == thread_id)
    )
    thread_data = result.scalar_one_or_none()
    
    if not thread_data:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Thread not found")
        
    thread_data.posts.sort(key=lambda post: post.created_at)

    # NEW: Populate the `has_voted` field for each post
    if user_id:
        user_votes_query = await db.execute(
            select(PostVote.post_id).filter(PostVote.user_id == user_id)
        )
        user_voted_post_ids = {row[0] for row in user_votes_query.all()}
        for post in thread_data.posts:
            if post.id in user_voted_post_ids:
                post.has_voted = True

    return thread_data

@router.post("/forum/threads", response_model=ForumThreadResponse, status_code=status.HTTP_201_CREATED)
async def create_new_thread(thread_data: ForumThreadBase, category_id: int, current_user: User = Depends(get_current_active_user), db: AsyncSession = Depends(get_db)):
    """Create a new forum thread and its first post."""
    category = await db.get(ForumCategory, category_id)
    if not category:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Category not found")
    
    new_thread = ForumThread(title=thread_data.title, category_id=category_id, author_id=current_user.id)
    db.add(new_thread)
    await db.commit()
    await db.refresh(new_thread)
    
    first_post = ForumPost(content=thread_data.content, thread_id=new_thread.id, author_id=current_user.id)
    db.add(first_post)
    await db.commit()
    await db.refresh(first_post)

    # Eagerly load relationships for the response
    await db.refresh(new_thread, attribute_names=['author', 'posts'])
    await db.refresh(first_post, attribute_names=['author'])
    return new_thread


@router.post("/forum/posts/{thread_id}", response_model=ForumPostResponse, status_code=status.HTTP_201_CREATED)
async def create_new_post(thread_id: int, post_data: ForumPostBase, current_user: User = Depends(get_current_active_user), db: AsyncSession = Depends(get_db)):
    """Create a new post in a thread."""
    thread = await db.get(ForumThread, thread_id)
    if not thread:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Thread not found")

    if thread.is_locked:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="This thread is locked and cannot be replied to.")

    new_post = ForumPost(
        content=post_data.content,
        thread_id=thread_id,
        author_id=current_user.id,
        parent_post_id=post_data.parent_post_id
    )
    db.add(new_post)
    await db.commit()
    await db.refresh(new_post)
    await db.refresh(new_post, attribute_names=['author'])
    return new_post

# MODIFIED: Upvote endpoint with better response and logic
@router.post("/forum/posts/{post_id}/vote", response_model=VoteResponse)
async def vote_for_post(post_id: int, current_user: User = Depends(get_current_active_user), db: AsyncSession = Depends(get_db)):
    """Vote for a specific post. Currently only supports upvoting."""
    post = await crud_forum.get_post_by_id(db, post_id=post_id)
    if not post:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Post not found.")

    existing_vote = await crud_forum.get_vote_by_user_and_post(db, user_id=current_user.id, post_id=post_id)
    if existing_vote:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="You have already voted for this post.")
        
    await crud_forum.create_vote(db, user_id=current_user.id, post_id=post_id)
    
    # We refresh the post object to get the updated vote count
    await db.refresh(post)
    
    return VoteResponse(
        post_id=post.id,
        current_votes=post.num_votes,
        message="Vote registered successfully."
    )

@router.post("/forum/threads/{thread_id}/subscribe", status_code=status.HTTP_204_NO_CONTENT)
async def subscribe_to_thread(thread_id: int, current_user: User = Depends(get_current_active_user), db: AsyncSession = Depends(get_db)):
    """Subscribe the current user to a forum thread for notifications."""
    existing_subscription_query = select(ForumSubscription).filter(
        ForumSubscription.thread_id == thread_id,
        ForumSubscription.user_id == current_user.id
    )
    existing_subscription = (await db.execute(existing_subscription_query)).scalar_one_or_none()

    if existing_subscription:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="You are already subscribed to this thread.")

    new_subscription = ForumSubscription(thread_id=thread_id, user_id=current_user.id)
    db.add(new_subscription)
    await db.commit()
    return {"message": "Subscribed successfully."}
